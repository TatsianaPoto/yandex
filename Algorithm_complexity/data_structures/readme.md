arr.py

~~~sql
Алгоритм по структурам данных обычный массив представляет собой одномерный массив, который предоставляет доступ к элементам по индексам. Он может быть использован для хранения последовательных элементов данных и обеспечивает эффективный доступ к элементам по индексу, но не обладает динамическим размером (размер фиксирован).

Сложность операций на обычном массиве:

Доступ по индексу: O(1) - операция выполняется за постоянное время, так как массив предоставляет прямой доступ к элементам по индексу.
Вставка/удаление элемента: O(n) - так как массив имеет фиксированный размер, вставка или удаление элемента может потребовать перемещения всех последующих элементов для освобождения или занятия места.
Поиск элемента по значению: O(n) - в худшем случае, потребуется проверить все элементы массива.
Обычные массивы эффективны при операциях доступа по индексу, но неэффективны при вставке/удалении элементов или при поиске элемента по значению. Если требуется частое добавление/удаление элементов или поиск по значению, более подходящими структурами данных могут быть динамические массивы или хэш-таблицы.
~~~

list.py

~~~sql
Динамический массив, также называемый "список" в Python, представляет собой структуру данных, которая автоматически изменяет свой размер при добавлении или удалении элементов. В Python динамический массив реализуется встроенным типом данных "list".

Сложность операций на динамическом массиве (встроенный тип "list" в Python):

Доступ по индексу: O(1) - операция выполняется за постоянное время, так как список предоставляет прямой доступ к элементам по индексу.
Вставка/удаление элемента в конец списка: O(1) в среднем, O(n) в худшем случае - добавление или удаление элемента в конец списка занимает постоянное время в среднем, так как динамический массив может выделять дополнительное место, чтобы избежать перераспределения памяти. В худшем случае, когда требуется перераспределение памяти, сложность становится линейной, так как все элементы списка могут потребовать копирования в новую область памяти.
Вставка/удаление элемента в произвольное место списка: O(n) - вставка или удаление элемента в середине списка потребует перемещения всех последующих элементов.
Поиск элемента по значению: O(n) - в худшем случае, потребуется проверить все элементы списка.
Общая сложность операций на динамическом массиве зависит от типа операции и может варьироваться от O(1) до O(n). Динамический массив хорошо подходит для операций доступа по индексу и быстрого добавления/удаления элементов в конец списка. Однако, если требуется частая вставка/удаление элементов в середине списка или поиск элементов по значению, более эффективными структурами данных могут быть связанные списки или хэш-таблицы.
~~~

linked_list.py

~~~sql
Односвязный список - это структура данных, состоящая из узлов, каждый из которых содержит значение и ссылку на следующий узел в списке. Последний узел списка ссылается на None, что означает конец списка.

Сложность операций для односвязного списка:

Вставка элемента в конец списка (метод append): O(n), так как для добавления элемента в конец списка нужно пройтись по всему списку до последнего элемента.
Поиск элемента в списке (метод search): O(n), так как для поиска элемента нужно пройтись по всему списку до тех пор, пока не будет найден искомый элемент.
Вывод всех элементов списка (метод print_list): O(n), так как для вывода всех элементов списка нужно пройтись по всему списку и вывести значения всех узлов.
~~~

bin_list.py

~~~sql


Двусвязный список - это структура данных, похожая на односвязный список, но каждый узел содержит две ссылки: одну на следующий узел и одну на предыдущий узел. Таким образом, двусвязный список можно обходить как в прямом, так и в обратном направлении.

Вставка элемента в конец списка (метод append): O(n), так как для добавления элемента в конец списка нужно пройтись по всему списку до последнего элемента.
Вывод всех элементов списка в прямом порядке (метод print_forward): O(n), так как для вывода всех элементов списка в прямом порядке нужно пройтись по всему списку от головы до хвоста.
Вывод всех элементов списка в обратном порядке (метод print_backward): O(n), так как для вывода всех элементов списка в обратном порядке нужно пройтись по всему списку от хвоста до головы.
~~~

skip_list.py

~~~sql
Список с пропусками (Skip List) - это структура данных, которая представляет собой расширение упорядоченного связанного списка. В Skip List каждый узел содержит ссылки на следующий узел в обычном связанном списке и на следующий узел через несколько уровней (skip-уровней). Это позволяет ускорить поиск элементов, так как пропускаются некоторые узлы на каждом уровне.

Вставка элемента в список (метод insert): O(log n), так как на каждом уровне пропускается некоторое количество узлов, а количество уровней ограничено.
Поиск элемента в списке (метод search): O(log n), так как на каждом уровне пропускается некоторое количество узлов, а количество уровней ограничено.
~~~

hash_tab.py

~~~sql
Хэш-таблица (или просто хеш) - это структура данных, которая позволяет хранить пары ключ-значение и обеспечивает эффективное выполнение операций вставки, поиска и удаления элементов. Она основана на использовании хеш-функции для преобразования ключей в индексы массива, где хранятся значения.

Основные операции с хеш-таблицей:

Вставка: Добавление новой пары ключ-значение в хеш-таблицу.
Поиск: Поиск значения по заданному ключу.
Удаление: Удаление пары ключ-значение из хеш-таблицы.
Принцип работы хеш-таблицы основан на быстром доступе к элементам по ключу. Хеш-функция преобразует ключи в индексы массива, и значения хранятся в соответствующих ячейках массива. Конфликты могут возникать, когда двум разным ключам соответствует один и тот же индекс массива (коллизии). Разрешение коллизий - это процесс устранения этой проблемы, и в хеш-таблицах используют различные методы для этого, например, метод цепочек или метод открытой адресации.

Вставка элемента (метод insert): O(1) в среднем случае, так как обычно конфликты редки и простая хеш-функция быстро вычисляет индекс массива.
Поиск элемента по ключу (метод search): O(1) в среднем случае, так как обычно конфликты редки и простая хеш-функция быстро вычисляет индекс массива.
Удаление элемента (метод remove): O(1) в среднем случае, так как обычно конф
~~~

bin_tree.py

~~~sql
Бинарное дерево поиска (Binary Search Tree, BST) - это структура данных, которая представляет собой иерархическую структуру, состоящую из узлов, где каждый узел содержит ключ (значение) и ссылки на левого и правого потомка. При этом для каждого узла выполняются следующие условия:

Значение в левом поддереве меньше значения в узле.
Значение в правом поддереве больше значения в узле.
Оба поддерева также являются бинарными деревьями поиска.
Эти свойства позволяют эффективно выполнять операции вставки, поиска и удаления элементов.

Операции с бинарным деревом поиска:

Вставка: добавление нового узла с заданным значением в правильное место в дереве.
Поиск: поиск узла с заданным значением в дереве.
Удаление: удаление узла с заданным значением из дерева.

Сложность операций в бинарном дереве поиска:
Вставка элемента (метод insert): В сбалансированном дереве - O(log n), в худшем случае (несбалансированное дерево) - O(n).
Поиск элемента по значению (метод search): В сбалансированном дереве - O(log n), в худшем случае (несбалансированное дерево) - O(n).
Удаление элемента (метод delete): В сбалансированном дереве - O(log n), в худшем случае (не
~~~

decart_tree.py

~~~sql
Декартово дерево (Cartesian tree) - это структура данных, которая является комбинацией двух других структур данных: бинарного дерева поиска и кучи (heap). Каждый узел декартового дерева имеет два значения: ключ (значение) и приоритет. Свойства декартового дерева:

Каждый узел декартового дерева имеет свою пару значений (ключ, приоритет).
Для каждого узла выполняется свойство бинарного дерева поиска: ключи в левом поддереве меньше ключа узла, а ключи в правом поддереве больше ключа узла.
Для каждого узла выполняется свойство кучи: приоритет узла не меньше приоритетов его потомков.
Декартово дерево обеспечивает эффективную реализацию следующих операций:

Вставка элемента с заданным ключом и приоритетом.
Удаление элемента с заданным ключом.
Поиск элемента с заданным ключом.
Обход дерева (возможны различные варианты обхода).

Сложность операций в декартовом дереве:

Вставка элемента (метод insert): В сбалансированном дереве - O(log n), в худшем случае (несбалансированное дерево) - O(n).
Удаление элемента (метод delete): В сбалансированном дереве - O(log n), в худшем случае (несбалансированное дерево) - O(n).
Поиск элемента по ключу (метод search): В сбалансированном дереве - O(log n), в худшем случае (несбалансированное дерево) - O(n).
~~~

b_tree.py

~~~sql
Б-дерево (B-tree) - это сбалансированное дерево, которое обладает следующими свойствами:

У каждого узла есть не более M ключей.
У каждого узла, кроме корня, есть не менее M/2 ключей.
У корня либо 1, либо не менее M/2 ключей.
Все листья находятся на одном уровне.
Каждый узел содержит не менее M/2+1 потомка и не более M потомков.
Сбалансированность B-дерева достигается чередованием узлов с данными и узлов-разделителей.

Вставка элемента (метод insert): O(log n), где n - количество ключей в дереве.
Поиск элемента по ключу (метод search): O(log n), где n - количество ключей в дереве.
~~~

r_b_tree.py

~~~sql
Красно-черное дерево (Red-Black Tree) - это сбалансированное бинарное дерево поиска, в котором каждый узел имеет цвет: красный или черный. Это дерево должно удовлетворять определенным свойствам:

Каждый узел является либо красным, либо черным.
Корень дерева всегда черный.
Листья (NIL-узлы) дерева также считаются черными.
Если узел красный, то оба его дочерних узла черные.
Все простые пути от узла до его листьев должны содержать одинаковое количество черных узлов (черная высота).
Такие свойства обеспечивают балансировку дерева и гарантируют, что его высота не превышает O(log n), где n - количество узлов.
Вставка элемента (метод insert): O(log n), где n - количество узлов в дереве.
Поиск элемента по ключу (метод search): O(log n), где n - количество узлов в дереве.
~~~

splay_tree.py

~~~sql
Расширяющееся дерево (Splay Tree) - это самобалансирующееся бинарное дерево поиска, которое при каждой операции доступа к узлу (поиске, вставке, удалении) перестраивается так, чтобы искомый узел оказался в корне дерева. Это позволяет улучшить производительность, так как часто запрашиваемые узлы перемещаются ближе к корню и будут быстрее доступны при последующих запросах.

Основная идея работы Splay Tree заключается в использовании поворотов, называемых "splaying", чтобы переместить искомый узел в корень. В результате, часто запрашиваемые узлы будут ближе к корню, что ускоряет последующие запросы к ним.

Вставка элемента (метод insert): Сложность в среднем O(log n), где n - количество узлов в дереве. Однако, в худшем случае (когда дерево несбалансированное), сложность может достигать O(n).
Поиск элемента по ключу (метод search): Сложность в среднем O(log n), где n - количество узлов в дереве. Однако, в худшем случае (когда дерево несбалансированное), сложность может достигать O(n).
Вывод дерева на экран (метод print_tree): O(n), так как нужно пройти по всем узлам дерева. В худшем случае также может быть O(n) при несбалансированном дереве.
~~~

avl_tree.py

~~~sql
AVL-дерево (Adelson-Velsky and Landis tree) - это самобалансирующееся бинарное дерево поиска, в котором для каждого узла высоты его двух поддеревьев различаются не более чем на 1. Это означает, что дерево сохраняет баланс после каждой операции вставки или удаления узлов.

Основная идея AVL-дерева заключается в автоматической балансировке дерева путем поворотов, которые выполняются после каждой операции вставки или удаления узлов. При вставке нового узла, дерево проверяется на нарушение баланса (разница высот поддеревьев не должна быть больше 1), и если нарушение обнаружено, выполняются соответствующие повороты, чтобы восстановить баланс.

Вставка элемента (метод insert): Сложность O(log n), где n - количество узлов в дереве. Это происходит из-за необходимости поддерживать баланс и проведения поворотов, которые в худшем случае потребуют перебалансировки дерева до его высоты (log n).
Вывод дерева на экран (метод print_tree): O(n), так как нужно пройти по всем узлам дерева. В худшем случае также может быть O(n), если дерево является несбалансированным.
~~~
