dfs.py

~~~sql
Алгоритм поиска в глубину (Depth-First Search, DFS) используется для обхода графов и деревьев. Он начинает с вершины-начала и рекурсивно идет вглубь по каждой непосещенной вершине до тех пор, пока не будет исследован весь граф. В процессе обхода алгоритм помечает посещенные вершины и может выполнять дополнительные действия на каждом шаге (например, сбор информации о путях или свойствах графа).
Алгоритм DFS реализуется обычно через рекурсивную функцию или с использованием стека для хранения текущего состояния. В данном случае мы реализуем рекурсивный вариант.
Вот простой скрипт на Python, который выполняет DFS для обхода графа, представленного в виде списка смежности. 

Сложность алгоритма поиска в глубину зависит от количества вершин и ребер в графе. Временная сложность составляет O(V + E), где V - количество вершин, а E - количество ребер в графе. В худшем случае алгоритм посетит каждую вершину и каждое ребро один раз.
~~~

bfs.py

~~~sql
Алгоритм поиска в ширину (BFS - Breadth-First Search) представляет собой обход графа, начиная с заданной вершины, и постепенно расширяя обход на все ближайшие соседние вершины, пока не будут обойдены все вершины, достижимые из начальной вершины. Он работает на основе использования очереди.

Основные шаги алгоритма BFS:
Поместить начальную вершину в очередь.
Помечать вершину как посещенную и извлекать ее из очереди.
Обойти все соседние вершины текущей вершины, которые еще не были помечены и добавить их в очередь.
Повторить шаги 2 и 3 до тех пор, пока очередь не станет пустой.

Сложность алгоритма BFS зависит от размера графа и его структуры. В худшем случае, когда все вершины связаны между собой, сложность составляет O(V + E), где V - количество вершин, E - количество ребер.

~~~

binary_search.py 

~~~sql
Алгоритм бинарного поиска (Binary Search) предназначен для поиска элемента в упорядоченном списке. Он работает за логарифмическое время и является эффективным для больших объемов данных. Основная идея заключается в том, что на каждом шаге алгоритм делит текущий диапазон поиска пополам и проверяет элемент в его середине. Если элемент равен искомому, поиск завершается. Если искомый элемент меньше или больше текущего элемента, поиск продолжается в соответствующей половине диапазона.

Сам алгоритм бинарного поиска можно представить в виде следующих шагов:

Установить начальные значения левой и правой границ диапазона: left = 0, right = len(arr) - 1.
Пока левая граница меньше или равна правой границе, выполнять следующее:
Вычислить индекс среднего элемента: mid = (left + right) // 2.
Сравнить элемент с индексом mid с искомым элементом.
Если элемент с индексом mid равен искомому, возвратить индекс mid.
Если элемент с индексом mid больше искомого, обновить правую границу: right = mid - 1.
Если элемент с индексом mid меньше искомого, обновить левую границу: left = mid + 1.
Если элемент не найден, вернуть -1.
Сложность алгоритма бинарного поиска составляет O(log n), где n - количество элементов в упорядоченном списке.
~~~

linear _search.py

~~~sql
Алгоритм линейного поиска (Linear Search) предназначен для поиска элемента в списке путем последовательного просмотра всех элементов. Он прост и прямолинеен, но имеет линейную сложность и может быть неэффективным для больших объемов данных. Основная идея заключается в том, чтобы пройтись по всем элементам списка и сравнить каждый элемент с искомым. Если элемент найден, поиск завершается, и возвращается его индекс.

Сам алгоритм линейного поиска можно представить в виде следующих шагов:
Пройтись по всем элементам списка последовательно, начиная с первого элемента.
Сравнить каждый элемент с искомым элементом.
Если элемент равен искомому, вернуть его индекс.
Если элемент не найден после просмотра всех элементов, вернуть -1.

Сложность алгоритма линейного поиска составляет O(n), где n - количество элементов в списке.

~~~

dijkstra_binary.py

~~~sql
Алгоритм Дейкстры - это алгоритм поиска кратчайшего пути во взвешенном графе от одной из его вершин до всех остальных. Он использует жадный подход и работает для графов с неотрицательными весами ребер.

Алгоритм Дейкстры с использованием двоичной кучи в качестве очереди с приоритетом работает следующим образом:

Создается пустой список расстояний до каждой вершины и инициализируется бесконечными значениями. Расстояние до начальной вершины устанавливается равным 0.
Создается пустая двоичная куча, в которую добавляются все вершины графа с их текущими расстояниями.
Пока очередь с приоритетом не пуста:
a. Извлекается вершина с минимальным текущим расстоянием из очереди.
b. Проходится по всем соседним вершинам и обновляется их расстояние, если найден более короткий путь.
c. Обновленные вершины добавляются обратно в очередь с приоритетом.
После завершения алгоритма в списке расстояний будут содержаться кратчайшие расстояния от начальной вершины до всех остальных вершин.
Сложность алгоритма Дейкстры с использованием двоичной кучи зависит от способа реализации двоичной кучи. Общая сложность алгоритма с использованием двоичной кучи составляет O((V + E) * log(V)), где V - количество вершин в графе, E - количество ребер в графе.
~~~

dijkstra_arr.py

~~~sql
Использование массива в качестве очереди с приоритетом в алгоритме Дейкстры подразумевает использование стандартных операций поиска минимального элемента в массиве. Когда нам нужно найти вершину с минимальным текущим расстоянием, мы просто проходим по всем вершинам в массиве и выбираем ту, у которой значение расстояния минимально.

Сложность операции поиска минимального элемента в массиве равна O(n), где n - количество элементов в массиве. В худшем случае, когда мы ищем минимальный элемент на каждой итерации алгоритма, суммарная сложность алгоритма Дейкстры с использованием массива в качестве очереди с приоритетом составляет O(V^2 + E), где V - количество вершин в графе, E - количество ребер в графе.
~~~

bellman_ford.py

~~~sql
Алгоритм Беллмана-Форда предназначен для нахождения кратчайших путей от одной из вершин до всех остальных вершин во взвешенном графе с возможностью отрицательных весов ребер. Он может обрабатывать графы с отрицательными циклами, что является его преимуществом по сравнению с алгоритмом Дейкстры.

Суть алгоритма заключается в многократном релаксации всех ребер графа. На каждой итерации алгоритм обновляет кратчайшие расстояния до всех вершин, используя информацию из уже обработанных вершин. При наличии отрицательных циклов, на последнией итерации алгоритма будет произведено обновление расстояний до вершин, находящихся внутри цикла, что позволяет определить наличие отрицательного цикла.

Сложность алгоритма Беллмана-Форда зависит от количества вершин и ребер в графе, а именно O(V * E), где V - количество вершин, E - количество ребер. В худшем случае, алгоритм может выполнить V-1 итераций, чтобы корректно обработать все вершины графа. Каждая итерация занимает O(E) времени из-за необходимости релаксации всех ребер.
~~~

