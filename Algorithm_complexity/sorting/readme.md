quick_sort.py

~~~sql

Алгоритм быстрой сортировки (QuickSort) - это эффективный алгоритм сортировки, 
который работает по принципу "разделяй и властвуй". Он выбирает опорный элемент из массива и разделяет его на две подгруппы: элементы меньше опорного и элементы больше опорного. Затем алгоритм рекурсивно сортирует каждую подгруппу.
Сложность алгоритма быстрой сортировки зависит от выбора опорного элемента и может быть разной в худшем и лучшем случае:
В худшем случае: O(n^2), когда опорный элемент каждый раз оказывается минимальным или максимальным в массиве. Это происходит, например, если массив уже отсортирован или отсортирован в обратном порядке.
В среднем и лучшем случае: O(n*log(n)). В среднем быстрая сортировка дает хорошую производительность и обычно считается одним из самых быстрых алгоритмов сортировки.
~~~

merge_sort.py

~~~sql

Алгоритм сортировки слиянием (Merge Sort) - это эффективный алгоритм сортировки, который также использует принцип "разделяй и властвуй". Он разделяет исходный массив на две равные (или почти равные) половины, рекурсивно сортирует каждую половину, а затем сливает их в один отсортированный массив.

Сложность алгоритма сортировки слиянием всегда одинакова и равна O(n*log(n)), где n - количество элементов в исходном массиве. Это делает его одним из самых эффективных алгоритмов сортировки, независимо от расположения элементов в массиве.
~~~

heapsort.py

~~~sql
Сортировка пирамидой (Heapsort) - это эффективный алгоритм сортировки, который использует структуру данных "куча" (heap). Куча - это бинарное дерево, у которого выполняются два условия:

Узлы уровня k имеют меньшие значения, чем узлы уровня k+1 (двоичная куча).
Каждый узел имеет значение, не меньшее, чем значения его потомков (min-heap для сортировки по возрастанию, max-heap для сортировки по убыванию).
Сортировка пирамидой основана на следующих шагах:

Строим max-heap из исходного массива (построение кучи).
Первый элемент массива (корень кучи) является максимальным. Меняем его с последним элементом и удаляем его из кучи (уменьшаем размер кучи на 1).
Восстанавливаем свойство max-heap с вершины дерева (перекладываем нарушенный элемент вниз до тех пор, пока свойство не будет восстановлено).
Повторяем шаги 2-3 до тех пор, пока куча не будет пуста.
Массив будет отсортирован в обратном порядке (при сортировке по возрастанию). Если требуется отсортировать по убыванию, нужно построить min-heap.
Сложность сортировки пирамидой:

Построение кучи занимает O(n) времени.
Каждая операция "просеивание" занимает O(log n) времени.
Всего выполняется n-1 операций "просеивания" для сортировки.
Таким образом, общая сложность сортировки пирамидой составляет O(n*log n).
~~~

bubble_sort.py

~~~sql

Пузырьковая сортировка (Bubble Sort) - это простой алгоритм сортировки, который многократно проходит через список, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Проходы продолжаются до тех пор, пока список не будет отсортирован.

Алгоритм пузырьковой сортировки:
Начинаем сравнивать первый и второй элементы списка.
Если первый элемент больше второго, меняем их местами.
Переходим к следующей паре элементов и повторяем шаги 1-2 до конца списка.
После первого прохода наибольший элемент переместится на последнее место.
Повторяем проходы для оставшейся части списка без последнего элемента.
Процесс продолжается до тех пор, пока список полностью не отсортируется.
Сложность пузырьковой сортировки:

Лучший случай: O(n) - если список уже отсортирован, и нет необходимости в перестановках.
Худший случай и средний случай: O(n^2) - в общем случае нужно сделать n проходов, и в каждом проходе нужно выполнить n сравнений и возможно перестановок.
~~~

insertion_sort.py

~~~sql
Сортировка вставками (Insertion Sort) - это простой алгоритм сортировки, который строит отсортированный список один элемент за другим, вставляя каждый элемент в правильную позицию.

Алгоритм сортировки вставками:

Начинаем считать элементы списка, начиная со второго элемента.
Сравниваем текущий элемент с предыдущим элементом.
Если текущий элемент меньше предыдущего, перемещаем его налево до тех пор, пока не встретим элемент, который меньше текущего, или не дойдем до начала списка.
Вставляем текущий элемент в позицию, где он должен находиться в отсортированной части списка.
Повторяем шаги 2-4 для всех оставшихся элементов списка.
Сложность сортировки вставками:

Лучший случай: O(n) - если список уже отсортирован, и нет необходимости в перестановках.
Худший случай и средний случай: O(n^2) - когда список отсортирован в обратном порядке.

~~~

selection_sort.py

~~~sql
Сортировка выбором (Selection Sort) — это простой алгоритм сортировки, который на каждом шаге находит минимальный (или максимальный) элемент из неотсортированной части списка и перемещает его в начало этой части.

Алгоритм сортировки выбором:

Находим минимальный элемент в списке.
Меняем местами минимальный элемент с первым элементом списка.
Теперь первый элемент считается отсортированным.
Повторяем шаги 1-3 для оставшейся неотсортированной части списка.
Сложность сортировки выбором:

Всегда O(n^2) - вне зависимости от того, какой список передан на вход. Алгоритм выполняет n-1 проходов, чтобы найти минимальный элемент на каждой итерации.
~~~

bucket_sort.py

~~~sql
Алгоритм блочной сортировки:

Разделить входной список на несколько блоков (корзин) на основе значения элементов.
Отсортировать каждый блок (корзину), например, с помощью вставки или другого стабильного сортировочного алгоритма.
Объединить отсортированные блоки в итоговый отсортированный список.
Сложность блочной сортировки:

В среднем случае и в худшем случае - O(n^2), если каждый элемент попадает в одну корзину и нужно сортировать каждую корзину отдельно.
В лучшем случае (если элементы равномерно распределены по корзинам) - O(n + k), где k - количество корзин.
Примечание: В зависимости от распределения значений элементов и размера входного списка, блочная сортировка может быть эффективной для небольших и равномерно распределенных данных.
~~~

radix_sort.py

~~~sql
Поразрядная сортировка (Radix Sort) - это алгоритм сортировки, который сортирует элементы списка по отдельным разрядам чисел. Он работает с числами в представлении с фиксированным числом разрядов, например, с целыми числами или строками с фиксированной длиной. Алгоритм использует стабильную сортировку на каждом разряде для упорядочивания элементов.

Алгоритм поразрядной сортировки:

Определить количество разрядов (цифр) в наибольшем числе в списке.
Начиная с младшего разряда (единиц), отсортировать элементы списка с помощью стабильной сортировки (например, сортировки подсчетом или вставками) по значениям данного разряда.
Повторить сортировку для следующего разряда, начиная со второго справа и т.д., пока не будет отсортирован последний разряд (наибольший разряд).
Полученный список будет отсортирован по всем разрядам.
Сложность поразрядной сортировки:

В среднем и в худшем случае - O(n * k), где n - количество элементов в списке, а k - количество разрядов (цифр) в наибольшем числе. Обратите внимание, что если k является константой или ограниченным числом, то сложность может быть улучшена до O(n).
~~~