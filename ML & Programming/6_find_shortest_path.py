"""
Чтобы решить данную задачу, можно воспользоваться алгоритмом поиска в ширину (BFS), 
так как он позволяет находить кратчайшие пути в графе с невзвешенными ребрами. 
В нашем случае города и дороги между ними образуют граф без весов на ребрах.
"""

from collections import deque

# Функция для вычисления расстояния между двумя городами.
def distance(city1, city2):
    return abs(city1[0] - city2[0]) + abs(city1[1] - city2[1]) + abs(city1[2] - city2[2])

# Функция для поиска кратчайшего пути с помощью BFS (поиск в ширину).
def find_shortest_path(n, cities, max_distance, start_city, end_city):
    visited = [False] * n  # Массив для отслеживания посещенных городов
    queue = deque([(start_city, 0)])  # Очередь для BFS, каждый элемент - (город, расстояние до него)

    while queue:
        current_city, current_distance = queue.popleft()
        visited[current_city] = True

        if current_city == end_city:
            return current_distance  # Мы достигли конечного города, возвращаем расстояние

        for neighbor in range(n):
            # Проверяем, что соседний город не посещён и расстояние до него не превышает максимальное
            if not visited[neighbor] and distance(cities[current_city], cities[neighbor]) <= max_distance:
                queue.append((neighbor, current_distance + 1))  # Добавляем в очередь соседний город

    return -1  # Если не найден путь, возвращаем -1

if __name__ == "__main__":
    # Чтение входных данных
    n = int(input())
    cities = [tuple(map(int, input().split())) for _ in range(n)]
    max_distance = int(input())
    start_city, end_city = map(int, input().split())

    # Поиск кратчайшего пути и вывод результата
    shortest_path = find_shortest_path(n, cities, max_distance, start_city - 1, end_city - 1)
    print(shortest_path)



"""
В этом примере у нас 5 городов с указанными координатами и максимальное расстояние, 
которое Петя может преодолеть без дозаправки, равно 10. 
Также указаны начальный город (1) и конечный город (5). 
Программа выводит минимальное количество дорог, которое нужно проехать, чтобы попасть из города 1 в город 5.

python .\6_find_shortest_path.py
5
0 0 0
1 2 3
4 5 6
7 8 9 
10 11 12
10
1 5
4
"""


"""
Давайте оценим сложность данного алгоритма.
Создание списка visited и инициализация его значений занимает O(n) времени и памяти, где n - количество городов.
Создание очереди queue с одним элементом занимает O(1) времени и памяти.
Внутри цикла while queue выполняется BFS по всем соседним городам. 
В худшем случае BFS может обойти все города, поэтому количество итераций в цикле не превысит n.
В каждой итерации цикла выполняется проверка соседних городов и добавление их в очередь, 
что занимает константное время O(1).

Таким образом, общая сложность алгоритма составляет O(n) в худшем случае, 
когда все города являются соседними друг к другу и BFS посетит каждый город. 
В среднем случае сложность также будет близка к O(n), поскольку BFS обычно обходит только часть графа 
до достижения конечного города.
Данный алгоритм хорошо масштабируется и быстро обрабатывает города в пределах нескольких тысяч. 
Однако, при очень больших значениях n алгоритм может стать медленнее из-за обхода всех возможных соседей.
"""