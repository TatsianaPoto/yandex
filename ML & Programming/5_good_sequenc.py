"""
Для решения данной задачи, нам нужно найти такую нечетную перестановку индексов, что после её применения 
последовательность становится хорошей.

Для этого можно выполнить следующий алгоритм:
Вычислить расстояния между каждой точкой и базовой плоскостью Oxy, Oyz и Oxz.
Отсортировать точки по каждому из расстояний (получим три отсортированных списка точек для каждой плоскости).
Выбрать такую перестановку индексов, чтобы индексы точек в каждом из трех списков точек были нечётными 
(таким образом, мы получим нечётную перестановку).

"""

def calculate_distance(point):
    x, y, z = point
    return x*x + y*y, y*y + z*z, x*x + z*z

def find_good_sequence(points):
    distances = [calculate_distance(point) for point in points]
    sorted_indices = list(range(len(points)))

    # Сортируем точки по каждому расстоянию
    sorted_indices.sort(key=lambda i: distances[i][0])
    odd_indices = [i for i in sorted_indices if i % 2 == 1]  # Нечетные индексы

    # Если нечётных индексов не хватает, дополняем их чётными
    if len(odd_indices) < len(points) // 2:
        sorted_indices.sort(key=lambda i: distances[i][1])
        even_indices = [i for i in sorted_indices if i % 2 == 0]  # Чётные индексы
        odd_indices += even_indices[:len(points) // 2 - len(odd_indices)]

    # Выводим перестановку индексов
    return [i+1 for i in odd_indices]

if __name__ == "__main__":
    n = int(input())
    points = [tuple(map(int, input().split())) for _ in range(n)]

    sequence = find_good_sequence(points)
    print(*sequence)


"""
python .\5_good_sequenc.py

4
1 1 1
2 4 16
3 9 81
4 16 256

2 4
"""

"""
Давайте оценим сложность данного алгоритма.
Функция calculate_distance(point) содержит простые операции, которые выполняются за O(1).
Создание списка distances выполняется для каждой точки из списка points, 
что занимает O(n) времени и памяти, где n - количество точек.
Создание списка sorted_indices занимает O(n) времени и памяти, где n - количество точек.
Сортировка списка sorted_indices по каждому расстоянию выполняется за O(n log n) времени.
Создание списка odd_indices и его дополнение до нужного размера занимает O(n) времени.
Создание списка sequence из индексов и выполнение вывода занимает O(n) времени.

Общая сложность алгоритма можно оценить как O(n log n) из-за сортировки, 
которая доминирует над остальными операциями с линейной сложностью. 
Это хорошая сложность для обработки списков точек в пределах нескольких тысяч. 
Однако, при больших значениях n сортировка может начать замедлять алгоритм.
"""