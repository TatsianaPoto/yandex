MOD = 10**9 + 7

def max_damage(n, a):
    num_groups = n // a  # Количество групп с a юнитами
    extra_units = n % a  # Оставшиеся юниты после разделения на группы

    # Вычисляем общий урон, учитывая количество групп
    total_damage = pow(a, num_groups, MOD)

    # Условие, если оставшиеся юниты позволяют создать дополнительные группы
    if extra_units > 0:
        # Вычисляем количество дополнительных групп
        num_extra_groups = min(a, extra_units)
        total_damage = (total_damage * pow(a, num_extra_groups, MOD)) % MOD

        # Оставшиеся юниты добавляем в последнюю группу
        total_damage = (total_damage * (extra_units - num_extra_groups + 1)) % MOD

    return total_damage

if __name__ == "__main__":
    n, a = map(int, input().split())
    result = max_damage(n, a)
    print(result)


"""
Давайте оценим сложность этого алгоритма.
Обозначим n - количество юнитов, a - количество юнитов в группе.

Вычисление количества групп: num_groups = n // a - выполняется за O(1), 
так как это простая арифметическая операция.
Вычисление оставшихся юнитов после разделения на группы: extra_units = n % a - также выполняется за O(1), 
так как это тоже арифметическая операция.
Вычисление общего урона с учетом количества групп: total_damage = pow(a, num_groups, MOD) - 
выполняется за O(log num_groups), где log - логарифм по основанию 2, 
потому что функция pow использует быстрое возведение в степень.
Условие, если оставшиеся юниты позволяют создать дополнительные группы: 
Выполнение этого условия также занимает O(log num_extra_groups) времени, где num_extra_groups - 
количество дополнительных групп.
В целом, сложность алгоритма составляет O(log n), 
так как наиболее времязатратной операцией является возведение в степень, 
итераций в цикле у нас нет, и остальные операции выполняются за константное время O(1).

Сложность O(log n) является эффективной, и алгоритм должен хорошо масштабироваться даже для больших значений n.
"""