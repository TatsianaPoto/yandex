def determine_winner(n, cards):
    if n % 3 != 0:
        raise ValueError("Количество карточек должно быть кратно трем.")

    petya_sum = 0
    vasya_sum = 0

    for i, card in enumerate(cards):
        if i % 2 == 0:  # Петя (игрок с четным индексом) берет карту
            petya_sum += card
        else:          # Вася (игрок с нечетным индексом) берет карту
            vasya_sum += card

    if petya_sum > vasya_sum:
        return "Petya"
    else:
        return "Vasya"


# Чтение входных данных
try:
    n = int(input())
    cards = list(map(int, input().split()))

    # Определение победителя и вывод результата
    winner = determine_winner(n, cards)
    print(winner)

except ValueError as e:
    print(e)


"""
Давайте оценим сложность данного алгоритма.
Проверка условия n % 3 != 0 - выполняется за O(1), так как это простая арифметическая операция.
Чтение входных данных n и cards - выполняется за O(n), где n - количество карточек.
Выполнение цикла for i, card in enumerate(cards): - выполняется за O(n), 
так как мы проходим по всем элементам списка cards.
Внутри цикла выполняется простая арифметическая операция для увеличения суммы 
petya_sum и vasya_sum, что также занимает O(1).
Определение победителя if petya_sum > vasya_sum: - выполняется за O(1), 
так как это простая условная операция.

Таким образом, общая сложность данного алгоритма составляет O(n), 
где n - количество карточек. Это линейная сложность, что означает, 
что время выполнения алгоритма будет линейно зависеть от размера входных данных (количество карточек). 
Алгоритм должен хорошо масштабироваться и быстро обрабатывать даже большие наборы карточек.
"""