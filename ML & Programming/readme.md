«Игра»


Решение задачи расположено в файле: 1_game.py

~~~sql
Условие:
Петя и Вася играют в игру: они по очереди берут из колоды карточки, на которых написаны целые неповторяющиеся положительные числа (первый карточку всегда берет Петя). 
Карточки игроки берут по одной сверху колоды. После этого они сравнивают значения, записанные на карточках: игрок, у которого меньше, тянет еще одну карточку и оставляет ее у себя. 
Когда все карточки заканчиваются, Петя и Вася считают сумму значений, написанных на этих карточках. Проигрывает тот, у кого сумма получается меньше, чем у другого игрока.
Им надоело вручную тянуть карточки и сравнивать значения. Они попросили вас написать программу, которая по исходному набору карточек будет определять победителя.
Гарантируется, что для любого теста победителя можно будет определить однозначно.

Ограничение по времени: 2 секунды
Ограничение по памяти: 64 МБ
~~~

«Сложные числа»

Решение задачи расположено в файле: 2_complex_numbers.py

~~~sql
Условие:
Обозначим через S(n) сумму цифр натурального числа n.
Будем говорить, что натуральное число n сложное, если не существует такого натурального числа k, что

n = 3k / s * (k)^2

Найдите наименьшее сложное число
~~~

~~~sql
Вместе с тем, Яндекс предлагает следующее решение:

Здесь можно придумать математическое решение, однако от нас требуется лишь найти наименьшее число, удовлетворяющее условию задачи. При этом ни доказательство, ни код писать не нужно, а времени на остальные задачи у нас не так много. Поэтому можно вместо поиска обоснованного решения воспользоваться перебором. Вот один из вариантов перебора: посчитаем значение функции для всех $k$ от 1 до некоторого предела (например, до миллиона) и, если оно целое, запомним, что такое число $n$ точно не будет сложным. Затем выведем наименьшее натуральное число, которое мы не запоминали в процессе вычисления нашей функции. В нашем примере это будет число 61.
~~~

«Турнирная таблица»

Решение задачи расположено в файле: 3_standings.py

~~~sql

Многие программисты любят играть в футбол. Некоторые даже любят проводить свои турниры. 
Но они не хотят следить за тем, кто сколько очков набрал и какое место занял, они хотят 
складывать результаты матчей в базу данных, после чего получать турнирную таблицу с количеством 
набранных очков и итоговым положением.

Одна из таких групп программистов попросила вас помочь им и, 
пока они собирают команды и проводят свой турнир, написать программу, 
которая будет строить итоговую турнирную таблицу.

Формат входных данных:

Входные данные представляют собой набор строк, каждая строка описывает 
ровно один сыгранный матч. В каждой строке записаны названия играющих друг с другом команд 
и результат матча. Названия и результат разделяются знаком тире, отбитым с обеих сторон пробелами. 
Каждое название состоит только из латинских букв, начинается с заглавной буквы, все остальные буквы строчные, гарантируется что длина каждого названия не превосходит 30 символов. 
Счет записывается в виде A:B, где A — количество голов, забитых первой командой, 
а B — количество голов, забитых второй командой. Победившей считается команда, забившая больше голов. 
Если забито одинаковое количество голов, результатом матча считается ничья. 
За победу команде присуждается три очка, за ничью — одно, за поражение — ноль.

Гарантируется, что нет ни одной пары команд с одинаковыми названиями, 
что ни одна пара команд не играла между собой более одного раза. 
Общее число команд-участников не превосходит 100. Ни в одном матче не было забито больше ста голов.

Формат выходных данных:

Вам нужно построить турнирную таблицу с результатами.
Каждая строка таблицы — представление результатов каждой из команд, команды должны быть упорядочены в лексикографическом порядке. В первом столбце содержится порядковый номер команды, во втором — название. 
Далее следуют n столбцов, в каждом из которых содержится информация об играх с остальными командами: 
в случае победы в ячейке должна присутствовать буква W, в случае поражения — L, в случае ничьей — D, 
если участники не играли друг с другом — пробел, если заполняется ячейка матча игрока с самим собой, 
то туда следует поставить символ X.

В последних двух столбцах должно быть выписано количество набранных командой очков и итоговое место.
Команда A занимает более высокое место, чем команда B, если она набрала большее количество очков, 
или они обе набрали одинаковое количество очков, но команда A одержала больше побед, чем команда B. 
Если же число очков и число побед у команд одинаковое, они занимают одно и то же место. 
Для простоты награждения требуется присудить только места с первого по третье.

Все столбцы должны иметь минимально возможную ширину, чтобы вместить данные в каждой строке. 
Для столбцов, содержащих порядковые номера, количество набранных очков и занятые места, все данные 
выравниваются по правому краю, все названия выравниваются по левому краю, после каждого названия в таблице 
должен гарантированно присутствовать пробел.
~~~


«Кошельки и монеты»

Решение задачи расположено в файле: 4_Purses_and_coins.py

~~~sql
Условие

Программист Петя очень любит складывать все имеющиеся у него деньги в кошельки и фиксировать, 
сколько денег лежит в каждом кошельке. Для этого он сохраняет в файле набор целых положительных чисел —
количество денег, которое лежит в каждом из его кошельков (Петя не любит, когда хотя бы один из его кошельков пустует). Петя хранит все деньги в монетах, номинал каждой монеты — 1 условная единица.

Однажды у Пети сломался блок магнитных головок и ему пришлось восстанавливать данные с жесткого диска. 
Он хочет проверить, корректно ли восстановились данные, и просит вас убедиться, что можно ту сумму денег, 
которая у него была, разложить во все его кошельки, чтобы получились те же числа, что и в восстановленном файле.

Формат входных данных

В первой строке выходных данных содержится 
натуральное число n  (1 <= n <= 100) — количество кошельков у Пети.
Во второй строке через пробел записаны данные из восстановленного файла: n натуральных чисел a_i, 
каждое из которых означает, сколько денег лежит в i-м кошельке у Пети (1 <= a_i <= 100).
В третьей строке записано натуральное число m (1 <= m <= 10^4) — общая сумма денег, 
которая была у Пети до того, как он разложил ее по кошелькам.

Формат выходных данных

Если в восстановленном файле нет ошибки, и исходную сумму можно разложить 
по кошелькам с указанной конфигурацией, выведите Yes. Если такой конфигурации 
не может существовать, выведите No.
~~~


«Хорошая последовательность»

Решение задачи расположено в файле: 5_good_sequenc.py

~~~sql
Условие

Последовательность точек на плоскости называется тривиальной, если она является строго упорядоченной 
по возрастанию или по убыванию расстояния до одной из точек этой последовательности.
Последовательность точек в трехмерном пространстве называется хорошей, если ни одна из последовательностей, полученных взятием проекции исходной на одну из базовых плоскостей (Oxy, Oyz и Oxz), не является тривиальной.

Дана последовательность из n точек с целочисленными координатами в трехмерном пространстве. 
Необходимо найти такую нечетную перестановку ее индексов, что после ее применения последовательность становится хорошей.

Гарантируется, что решение существует.
Дополнительные параметры
Формат входных данных

В первой строке входных данных записано целое число n(3 <= n <= 1000), 
в следующих n строчках через пробел записаны по три целочисленных координаты 
x_i, y_i, z_i  (-10^4 <= x_i, y_i, z_i <= 10^4) каждой из точек.

Гарантируется, что проекции всех точек на любую из базовых плоскостей различны.

Формат выходных данных

Выведите n чисел: искомая перестановка индексов от 1 до n. 
Если существует несколько решений, выведите любое из них. Числа в строке следует разделять пробелами.
~~~


«Интересное путешествие»

Решение задачи расположено в файле: 6_find_shortest_path.py

~~~sql
Условие:
Не секрет, что некоторые программисты очень любят путешествовать.
Хорошо всем известный программист Петя тоже очень любит путешествовать, посещать музеи и осматривать достопримечательности других городов.

Для перемещений из города в город он предпочитает использовать машину. 
При этом он заправляется только на станциях в городах, но не на станциях по пути. 
Поэтому он очень аккуратно выбирает маршруты, чтобы машина не заглохла в дороге. А еще Петя очень важный член команды, поэтому он не может себе позволить путешествовать слишком долго. Он решил написать программу, которая поможет ему с выбором очередного путешествия. Но так как сейчас у него слишком много других задач, он попросил вас помочь ему.

Расстояние между двумя городами считается как сумма модулей разности по каждой из координат. 
Дороги есть между всеми парами городов.

Формат входных данных:

В первой строке входных данных записано количество городов n(2 <= n <= 1000). В следующих n строках даны два целых числа: координаты каждого города, не превосходящие по модулю миллиарда. 
Все города пронумерованы числами от 1 до n в порядке записи во входных данных.

В следующей строке записано целое положительное число k, не превосходящее двух миллиардов, 
— максимальное расстояние между городами, которое Петя может преодолеть без дозаправки машины.

В последней строке записаны два различных числа — номер города, откуда едет Петя, и номер города, куда он едет.

Формат выходных данных:

Если существуют пути, удовлетворяющие описанным выше условиям, то выведите минимальное количество дорог, которое нужно проехать, чтобы попасть из начальной точки маршрута в конечную. Если пути не существует, выведите -1.
~~~


«Разделение числа»

Решение задачи расположено в файле: 7_split_number.py

~~~sql
Условие:
Дано число n Разбейте десятичную запись числа n на максимальное возможное количество различных чисел.
Использовать числа с незначащими нулями не разрешается.

Формат входных данных:
В единственной строке входных данных задано число n (0 <= n <= 10^19).

Формат выходных данных:
Выведите разбиение числа n на различные части. Между частями поставьте знак «-». Если есть несколько возможных разбиений, выведите любое.
~~~


«Максимальный урон»

Решение задачи расположено в файле:  8_max_damage.py

~~~sql
Условие

Программист Игорь очень любит играть в компьютерные игры. Больше всего Игорю нравятся стратегии, 
особенно те моменты, когда он отправляет группы своих юнитов атаковать вражеские базы. 
 довольно давно играет в стратегии, поэтому у него есть четко отработанный план действий при атаке: 
 он разбивает все свои юниты на группы и отправляет их в атаку поочередно. 
 При этом Игорь считает, что общий урон, который будет нанесен в атаке, равен произведению размеров групп. 
 Он пытается разбить свои юниты на группы так, чтобы максимизировать общий урон.

В последнее время Игорь стал часто проигрывать. Он уверен, что проблема в том, что в одной из групп после разбиения получается несчастливое количество юнитов. Он пытается переделать свой алгоритм разбиения и попросил вас посчитать, какой максимальный общий урон смогут нанести его группы, если среди них не будет ни одной, содержащей несчастливое количество юнитов.

Формат входных данных:

В единственной строке входных данных через пробел записаны натуральные числа n и
a(1 <= n, a <= 10^6, n <> a) — количество юнитов, которые есть у Игоря,
и число юнитов в группе, которое Игорь считает несчастливым.

Формат выходных данных:

Выведите максимально возможный общий урон по модулю 10^9 + 7.

В первом примере для максимизации общего урона следует разбить юниты на две группы по 4 юнита в каждом, во втором примерe — на две группы: в первой 4 юнита, во второй — 5.
~~~



«Красно-черные деревья»

Решение задачи расположено в файле:  9_count_red_black_trees.py
~~~sql
Условие:

Красно-черным деревом называется дерево, у которого все вершины покрашены в красный или черный цвет и есть еще дополнительные свойства:

Корень черного цвета.
Каждая вершина либо имеет два потомка, либо является листом (не имеет потомков).
Все листья дерева черного цвета.
У красных вершин оба потомка имеют черный цвет.
Количество черных вершин на пути от корня до любого листа дерева одинаково.
Найдите число неизоморфных красно-черных деревьев с заданным числом вершин. 
Два красно-черных дерева  T_1  и  T_2  являются изоморфными, если существует биекция между вершинами деревьев  f: V(T_1) \rightarrow V(T_2) , удовлетворяющая условиям:


f(root(T_1) = root(T_2)) , т. е. корень переходит в корень.
Если  f(v) = u  и у вершины  v  есть дети ( v_l  и  v_r ), то и у вершины  u  есть дети ( u_l  и  u_r ), 
при этом или  f(v_l) = u_l  и  f(v_r) = u_r , или  f(v_l) = u_r  и  f(v_r) = u_l .
 f  сохраняет цвет вершин, то есть  color (v) = color (f(v)) .

Формат входных данных:

В первой строке задано число вершин дерева  n  ( 1 <= n <= 1000 ).

Формат выходных данных:

Выведите число неизоморфных красно-черных деревьев с  n  вершинами по модулю 10^9 + 7.

~~~


«Все кроме одной»

Решение задачи расположено в файле:  10_find_position.py
~~~sql
Условие:
Даны  k  перестановок из  n  элементов, каждая из которых принадлежит к одному из  m  типов.
Посчитайте позицию первого элемента, если последовательно применить эти  k  перестановок, убрав одну из них.

Формат входных данных:

В первой строке входных данных заданы числа  n  и  m  ( 1 <= n <= 1000 ,  1 <= m <= 100 ).

В следующих  m  строках записано по  n  чисел.  i -е число описывает позицию, на которую нужно переставить  i -й элемент.

В следующей строке записано число  k  ( 1 <= k <= 5 * 10^4 ). В следующей строке записаны  k  чисел 
от 1 до  m  — типы перестановок в начальном наборе.
Формат выходных данных
Для каждой из  k  перестановок выведите в отдельной строке позицию первого элемента, 
если последовательно применить все остальные перестановки.
~~~


«Вложенные прямоугольники»


Решение задачи расположено в файле:  11_intersected_rectangles.py
~~~sql
Условие:

На клетчатой плоскости отмечено  n  клеток.
Для раскрашивания этих клеток проводятся следующие операции. 
На каждом шаге выбирается прямоугольник минимальной площади, 
содержащий все отмеченные, но не окрашенные, клетки, и все клетки 
на его границе перекрашиваются в новый цвет.

Определите, через сколько шагов неокрашенных клеток не останется.

Формат входных данных:
В первой строке входных данных задано число  n   (1 <= n <= 100000)  — количество отмеченных клеток. 
В следующих  n  строках заданы целые координаты  i -й отмеченной клетки  x_i, y_i   (|x_i| <= 10^9, |y_i| <= 10^9) . Все отмеченные клетки различны.

Формат выходных данных:
Выведите число шагов, после которых не останется неокрашенных клеток.
~~~


«Игра с числами»

Решение задачи расположено в файле:  12_find_equal_numbers.py

~~~sql
Условие

Дана последовательность  n  положительных чисел  a_1, a_2, …, a_n . Пока среди них есть различные, выполняется следующая операция: 
выбирается некоторое максимальное число и из него вычитается минимальное число.

Через сколько операций числа станут одинаковыми?

Формат входных данных

В первой строке входных данных задано число  n  ( 1 <= n <= 1000 ). В следующей строке заданы  n  чисел  a_i  ( 1 <= a_i <= 10^9 ).

Формат выходных данных:

Количество операций, после которых все числа станут одинаковыми.

~~~
